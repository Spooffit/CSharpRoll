using System.Text;

namespace CSharpRoll.Core;

/// <summary>
/// Writes rolled output file by concatenating project csproj (raw) and source files with separators.
/// </summary>
public static class RollWriter
{
    public static void Write(
        string outputPath,
        IReadOnlyList<RolledProject> projects,
        string rootDir,
        RollOptions options,
        string? solutionPath = null,
        RollDiagnostics? diagnostics = null)
    {
        var outDir = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrWhiteSpace(outDir))
            Directory.CreateDirectory(outDir);

        var filePathComparer = OperatingSystem.IsWindows()
            ? StringComparer.OrdinalIgnoreCase
            : StringComparer.Ordinal;

        // total unique file count across all projects (for header)
        var allUnique = new HashSet<string>(filePathComparer);
        foreach (var p in projects)
        foreach (var f in p.Files)
            allUnique.Add(f);

        using var stream = new FileStream(outputPath, FileMode.Create, FileAccess.Write, FileShare.Read);
        using var writer = new StreamWriter(stream, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));

        var now = DateTimeOffset.Now;
        var projectNames = projects.Select(p => p.Name).ToList();

        if (options.Format == OutputFormat.CSharp)
        {
            writer.WriteLine("// <auto-generated>");

            if (!string.IsNullOrWhiteSpace(solutionPath))
            {
                writer.WriteLine($"// Solution: {solutionPath}");
                if (diagnostics is not null)
                    writer.WriteLine($"// AnalysisMode: {diagnostics.AnalysisMode}");
            }

            WriteSolutionDiagnostics(writer, diagnostics, rootDir, options);

            writer.WriteLine($"// Rolled by CSharpRoll at {now:O}");
            writer.WriteLine($"// Projects: {string.Join(", ", projectNames)}");
            writer.WriteLine($"// Files: {allUnique.Count}");
            writer.WriteLine("// </auto-generated>");
            writer.WriteLine();
        }
        else
        {
            writer.WriteLine($"# CSharpRoll output ({now:O})");
            writer.WriteLine();
            writer.WriteLine($"- Projects: {string.Join(", ", projectNames)}");
            writer.WriteLine($"- Files: {allUnique.Count}");
            writer.WriteLine();

            if (!string.IsNullOrWhiteSpace(solutionPath))
            {
                writer.WriteLine($"- Solution: `{solutionPath}`");
                if (diagnostics is not null)
                    writer.WriteLine($"- AnalysisMode: `{diagnostics.AnalysisMode}`");
                writer.WriteLine();
            }

            WriteSolutionDiagnostics(writer, diagnostics, rootDir, options);
        }

        // global dedupe: linked/shared files across projects are written once
        var writtenFiles = new HashSet<string>(filePathComparer);

        foreach (var project in projects)
        {
            WriteProjectHeader(writer, project, options, rootDir, diagnostics);

            foreach (var file in project.Files)
            {
                if (!writtenFiles.Add(file))
                    continue;

                var rel = Path.GetRelativePath(rootDir, file);

                if (options.Format == OutputFormat.Markdown)
                {
                    writer.WriteLine($"### {rel}");
                    writer.WriteLine();
                    writer.WriteLine("```csharp");
                    writer.WriteLine($"// ===== File: {rel} =====");
                }
                else
                {
                    writer.WriteLine($"// ===== BEGIN FILE: {rel} =====");
                }

                WriteFileBody(writer, file, diagnostics);

                if (options.Format == OutputFormat.Markdown)
                {
                    writer.WriteLine("```");
                    writer.WriteLine();
                }
                else
                {
                    writer.WriteLine();
                    writer.WriteLine($"// ===== END FILE: {rel} =====");
                    writer.WriteLine();
                }
            }
        }
    }

    private static void WriteSolutionDiagnostics(TextWriter writer, RollDiagnostics? diagnostics, string rootDir, RollOptions options)
    {
        if (diagnostics is null || diagnostics.SolutionDiagnostics.Count == 0)
            return;

        if (options.Format == OutputFormat.CSharp)
        {
            writer.WriteLine("// ----- SOLUTION DIAGNOSTICS -----");
            foreach (var d in diagnostics.SolutionDiagnostics.OrderByDescending(x => x.Severity).ThenBy(x => x.Id, StringComparer.Ordinal))
                writer.WriteLine("// " + FormatDiagnosticLine(d, rootDir));
            writer.WriteLine("// ----- end solution diagnostics -----");
        }
        else
        {
            writer.WriteLine("## Diagnostics (solution)");
            foreach (var d in diagnostics.SolutionDiagnostics.OrderByDescending(x => x.Severity).ThenBy(x => x.Id, StringComparer.Ordinal))
                writer.WriteLine("- " + FormatDiagnosticLineMd(d, rootDir));
            writer.WriteLine();
        }
    }

    private static void WriteProjectHeader(TextWriter writer, RolledProject project, RollOptions options, string rootDir, RollDiagnostics? diagnostics)
    {
        if (options.Format == OutputFormat.CSharp)
        {
            writer.WriteLine($"// ===== PROJECT: {project.Name} =====");
            writer.WriteLine($"// Path: {project.CsprojPath}");

            WriteProjectDiagnostics(writer, project, diagnostics, rootDir, options);

            writer.WriteLine("// ----- .csproj (raw) -----");
            foreach (var line in SplitLines(project.CsprojRaw))
                writer.WriteLine("// " + line);
            writer.WriteLine("// ----- end .csproj (raw) -----");
            writer.WriteLine();
        }
        else
        {
            writer.WriteLine($"## Project: {project.Name}");
            writer.WriteLine();
            writer.WriteLine($"- Path: `{project.CsprojPath}`");
            writer.WriteLine($"- Files: `{project.Files.Count}`");
            writer.WriteLine();

            WriteProjectDiagnostics(writer, project, diagnostics, rootDir, options);

            writer.WriteLine("```xml");
            writer.WriteLine(project.CsprojRaw.TrimEnd());
            writer.WriteLine("```");
            writer.WriteLine();
        }
    }

    private static void WriteProjectDiagnostics(TextWriter writer, RolledProject project, RollDiagnostics? diagnostics, string rootDir, RollOptions options)
    {
        if (diagnostics is null)
            return;

        // ключи в ProjectDiagnostics у тебя абсолютные; на всякий случай нормализуем
        var csprojFull = Path.GetFullPath(project.CsprojPath);

        if (!diagnostics.ProjectDiagnostics.TryGetValue(csprojFull, out var list) || list.Count == 0)
            return;

        var ordered = list
            .OrderByDescending(x => x.Severity)
            .ThenBy(x => x.FilePath ?? "", StringComparer.OrdinalIgnoreCase)
            .ThenBy(x => x.Line ?? int.MaxValue)
            .ThenBy(x => x.Id, StringComparer.Ordinal);

        if (options.Format == OutputFormat.CSharp)
        {
            writer.WriteLine("// ----- PROJECT DIAGNOSTICS -----");
            foreach (var d in ordered)
                writer.WriteLine("// " + FormatDiagnosticLine(d, rootDir));
            writer.WriteLine("// ----- end project diagnostics -----");
            writer.WriteLine();
        }
        else
        {
            writer.WriteLine("### Diagnostics (project)");
            foreach (var d in ordered)
                writer.WriteLine("- " + FormatDiagnosticLineMd(d, rootDir));
            writer.WriteLine();
        }
    }

    private static IEnumerable<string> SplitLines(string text)
    {
        text = text.Replace("\r\n", "\n").Replace("\r", "\n");
        return text.Split('\n');
    }

    private static void WriteFileBody(TextWriter writer, string filePath, RollDiagnostics? diagnostics)
    {
        var text = ReadText(filePath);
        text = text.Replace("\r\n", "\n").Replace("\r", "\n");
        var lines = text.Split('\n');

        Dictionary<int, List<RollDiagnostic>>? byLine = null;
        if (diagnostics is not null)
            diagnostics.FileDiagnostics.TryGetValue(filePath, out byLine);

        for (var i = 0; i < lines.Length; i++)
        {
            var lineNumber = i + 1;

            if (byLine is not null && byLine.TryGetValue(lineNumber, out var diagsHere))
            {
                foreach (var d in diagsHere
                             .OrderByDescending(x => x.Severity) // Error выше
                             .ThenBy(x => x.Id, StringComparer.Ordinal))
                {
                    var sev = d.Severity == RollDiagnosticSeverity.Error ? "ERROR" : "WARNING";
                    var colPart = d.Column is not null ? $", col {d.Column}" : "";
                    writer.WriteLine($"// [{sev}] {d.Id}: {d.Message} (line {lineNumber}{colPart})");
                }
            }

            writer.WriteLine(lines[i]);
        }
    }

    private static string FormatDiagnosticLine(RollDiagnostic d, string rootDir)
    {
        var sev = d.Severity == RollDiagnosticSeverity.Error ? "ERROR" : "WARNING";
        var loc = FormatLocation(d, rootDir);
        return loc.Length == 0
            ? $"[{sev}] {d.Id}: {d.Message}"
            : $"[{sev}] {d.Id}: {d.Message} ({loc})";
    }

    private static string FormatDiagnosticLineMd(RollDiagnostic d, string rootDir)
    {
        var sev = d.Severity == RollDiagnosticSeverity.Error ? "**Error**" : "**Warning**";
        var loc = FormatLocation(d, rootDir);
        return loc.Length == 0
            ? $"{sev} `{d.Id}`: {d.Message}"
            : $"{sev} `{d.Id}`: {d.Message} ({loc})";
    }

    private static string FormatLocation(RollDiagnostic d, string rootDir)
    {
        if (string.IsNullOrWhiteSpace(d.FilePath))
            return "";

        var path = TryRel(rootDir, d.FilePath);
        if (d.Line is null)
            return path;

        if (d.Column is null)
            return $"{path}:{d.Line}";

        return $"{path}:{d.Line}:{d.Column}";
    }

    private static string TryRel(string rootDir, string fullPath)
    {
        try { return Path.GetRelativePath(rootDir, fullPath); }
        catch { return fullPath; }
    }

    private static string ReadText(string path)
    {
        try { return File.ReadAllText(path, new UTF8Encoding(false, true)); }
        catch { return File.ReadAllText(path); }
    }
}
